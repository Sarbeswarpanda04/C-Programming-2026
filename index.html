<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>C Folder Viewer</title>
		<style>
			:root {
				color-scheme: light dark;
			}
			body {
				margin: 0;
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
				line-height: 1.4;
			}
			header {
				padding: 16px;
				border-bottom: 1px solid CanvasText;
			}
			header h1 {
				margin: 0 0 8px 0;
				font-size: 18px;
				font-weight: 600;
			}
			.row {
				display: flex;
				gap: 16px;
				padding: 0 16px 16px;
				flex-wrap: wrap;
				align-items: center;
			}
			button {
				padding: 8px 12px;
				border-radius: 8px;
				border: 1px solid CanvasText;
				background: Canvas;
				color: CanvasText;
				cursor: pointer;
			}
			button:disabled {
				opacity: 0.6;
				cursor: not-allowed;
			}
			label {
				display: inline-flex;
				gap: 8px;
				align-items: center;
			}
			.hint {
				opacity: 0.85;
				font-size: 12px;
			}
			main {
				display: grid;
				grid-template-columns: 360px 1fr;
				gap: 0;
				min-height: calc(100vh - 86px);
			}
			nav {
				border-right: 1px solid CanvasText;
				overflow: auto;
			}
			section {
				overflow: auto;
			}
			.panel {
				padding: 12px 16px;
			}
			.tree {
				font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
				font-size: 13px;
			}
			.tree ul {
				list-style: none;
				padding-left: 18px;
				margin: 6px 0;
			}
			.tree li {
				margin: 2px 0;
			}
			.tree button.item {
				font: inherit;
				padding: 2px 6px;
				border-radius: 6px;
				border: 1px solid transparent;
				background: transparent;
				text-align: left;
			}
			.tree button.item:hover {
				border-color: CanvasText;
			}
			.tree button.item[aria-current="true"] {
				border-color: CanvasText;
			}
			pre {
				padding: 12px;
				border: 1px solid CanvasText;
				border-radius: 10px;
				overflow: auto;
				white-space: pre;
				background: Canvas;
			}
			.meta {
				display: flex;
				gap: 12px;
				flex-wrap: wrap;
				align-items: baseline;
				margin: 0 0 10px 0;
			}
			.path {
				font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
				font-size: 12px;
				opacity: 0.9;
				word-break: break-word;
			}
			.status {
				font-size: 12px;
				opacity: 0.85;
			}
			@media (max-width: 900px) {
				main {
					grid-template-columns: 1fr;
				}
				nav {
					border-right: none;
					border-bottom: 1px solid CanvasText;
					max-height: 40vh;
				}
			}
		</style>
	</head>
	<body>
		<header>
			<h1>C Programming Folder Viewer</h1>
			<div class="row">
				<button id="pickFolderBtn" type="button">Pick folderâ€¦</button>
				<input id="fallbackPicker" type="file" webkitdirectory multiple hidden />
				<button id="fallbackBtn" type="button" hidden>Pick folder (fallback)â€¦</button>

				<label>
					<input id="onlyC" type="checkbox" checked />
					show only <code>.c</code>
				</label>

				<button id="refreshBtn" type="button" disabled>Refresh</button>

				<span class="hint">Tip: Works best in Microsoft Edge / Chrome.</span>
			</div>
			<div class="row">
				<span id="status" class="status">No folder selected.</span>
			</div>
		</header>

		<main>
			<nav>
				<div class="panel">
					<div class="tree" id="tree"></div>
				</div>
			</nav>

			<section>
				<div class="panel">
					<div class="meta">
						<div>
							<div><strong id="selectedName">(select a file)</strong></div>
							<div class="path" id="selectedPath"></div>
						</div>
					</div>

					<pre id="viewer">Pick a folder, then click a .c file to view it here.</pre>
				</div>
			</section>
		</main>

		<script>
			/**
			 * Single-file local folder viewer.
			 * Uses File System Access API when available; falls back to <input webkitdirectory>.
			 */

			const pickFolderBtn = document.getElementById('pickFolderBtn');
			const fallbackBtn = document.getElementById('fallbackBtn');
			const fallbackPicker = document.getElementById('fallbackPicker');
			const onlyC = document.getElementById('onlyC');
			const refreshBtn = document.getElementById('refreshBtn');
			const statusEl = document.getElementById('status');
			const treeEl = document.getElementById('tree');
			const viewerEl = document.getElementById('viewer');
			const selectedNameEl = document.getElementById('selectedName');
			const selectedPathEl = document.getElementById('selectedPath');

			let rootHandle = null;
			let currentSelectionPath = null;
			let fallbackFiles = null;

			function setStatus(text) {
				statusEl.textContent = text;
			}

			function clearViewer() {
				selectedNameEl.textContent = '(select a file)';
				selectedPathEl.textContent = '';
				viewerEl.textContent = 'Pick a folder, then click a .c file to view it here.';
				currentSelectionPath = null;
			}

			function shouldShowFile(name) {
				if (!onlyC.checked) return true;
				return name.toLowerCase().endsWith('.c');
			}

			function escapeText(s) {
				return s.replace(/[&<>]/g, (c) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[c]));
			}

			function buildTreeNode(label, isFile) {
				const li = document.createElement('li');
				const btn = document.createElement('button');
				btn.type = 'button';
				btn.className = 'item';
				btn.innerHTML = escapeText(label);
				btn.dataset.isFile = isFile ? 'true' : 'false';
				li.appendChild(btn);
				return { li, btn };
			}

			function setCurrentButton(btn) {
				for (const b of treeEl.querySelectorAll('button.item')) {
					b.setAttribute('aria-current', 'false');
				}
				btn.setAttribute('aria-current', 'true');
			}

			async function readTextFromFileHandle(fileHandle) {
				const file = await fileHandle.getFile();
				return await file.text();
			}

			async function renderFromHandle(handle) {
				treeEl.textContent = '';
				clearViewer();

				const ul = document.createElement('ul');
				treeEl.appendChild(ul);

				let totalFiles = 0;
				let shownFiles = 0;

				async function walkDir(dirHandle, parentUl, prefixPath) {
					const entries = [];
					for await (const entry of dirHandle.values()) {
						entries.push(entry);
					}
					entries.sort((a, b) => {
						if (a.kind !== b.kind) return a.kind === 'directory' ? -1 : 1;
						return a.name.localeCompare(b.name);
					});

					for (const entry of entries) {
						const fullPath = prefixPath ? `${prefixPath}/${entry.name}` : entry.name;

						if (entry.kind === 'directory') {
							const { li, btn } = buildTreeNode(`ðŸ“ ${entry.name}`, false);
							parentUl.appendChild(li);

							const childUl = document.createElement('ul');
							li.appendChild(childUl);

							btn.addEventListener('click', () => {
								const hidden = childUl.hasAttribute('hidden');
								if (hidden) childUl.removeAttribute('hidden');
								else childUl.setAttribute('hidden', '');
							});

							await walkDir(entry, childUl, fullPath);
						} else {
							totalFiles++;
							if (!shouldShowFile(entry.name)) continue;
							shownFiles++;

							const { li, btn } = buildTreeNode(`ðŸ“„ ${entry.name}`, true);
							parentUl.appendChild(li);

							btn.addEventListener('click', async () => {
								setCurrentButton(btn);
								selectedNameEl.textContent = entry.name;
								selectedPathEl.textContent = fullPath;
								viewerEl.textContent = 'Loadingâ€¦';
								try {
									const text = await readTextFromFileHandle(entry);
									viewerEl.textContent = text;
									currentSelectionPath = fullPath;
								} catch (e) {
									viewerEl.textContent = `Failed to read file: ${e?.message || e}`;
								}
							});
						}
					}
				}

				await walkDir(handle, ul, '');
				setStatus(`Loaded folder. Showing ${shownFiles} of ${totalFiles} files.`);
			}

			function buildFallbackIndex(fileList) {
				// fileList: FileList from <input webkitdirectory>
				// Each File has webkitRelativePath like "C Programming/sub/abc.c".
				const files = Array.from(fileList);
				files.sort((a, b) => (a.webkitRelativePath || a.name).localeCompare(b.webkitRelativePath || b.name));

				const root = { name: '(root)', dirs: new Map(), files: [] };

				for (const file of files) {
					const rel = file.webkitRelativePath || file.name;
					const parts = rel.split('/').filter(Boolean);
					const fileName = parts.pop();
					let node = root;
					for (const part of parts) {
						if (!node.dirs.has(part)) node.dirs.set(part, { name: part, dirs: new Map(), files: [] });
						node = node.dirs.get(part);
					}
					node.files.push({ name: fileName, relPath: rel, file });
				}
				return root;
			}

			function renderFallbackTree(rootNode) {
				treeEl.textContent = '';
				clearViewer();

				const ul = document.createElement('ul');
				treeEl.appendChild(ul);

				let totalFiles = 0;
				let shownFiles = 0;

				function walk(node, parentUl) {
					const dirNames = Array.from(node.dirs.keys()).sort((a, b) => a.localeCompare(b));
					for (const dirName of dirNames) {
						const dirNode = node.dirs.get(dirName);
						const { li, btn } = buildTreeNode(`ðŸ“ ${dirName}`, false);
						parentUl.appendChild(li);

						const childUl = document.createElement('ul');
						li.appendChild(childUl);

						btn.addEventListener('click', () => {
							const hidden = childUl.hasAttribute('hidden');
							if (hidden) childUl.removeAttribute('hidden');
							else childUl.setAttribute('hidden', '');
						});

						walk(dirNode, childUl);
					}

					for (const f of node.files) {
						totalFiles++;
						if (!shouldShowFile(f.name)) continue;
						shownFiles++;

						const { li, btn } = buildTreeNode(`ðŸ“„ ${f.name}`, true);
						parentUl.appendChild(li);
						btn.addEventListener('click', async () => {
							setCurrentButton(btn);
							selectedNameEl.textContent = f.name;
							selectedPathEl.textContent = f.relPath;
							viewerEl.textContent = 'Loadingâ€¦';
							try {
								viewerEl.textContent = await f.file.text();
								currentSelectionPath = f.relPath;
							} catch (e) {
								viewerEl.textContent = `Failed to read file: ${e?.message || e}`;
							}
						});
					}
				}

				walk(rootNode, ul);
				setStatus(`Loaded folder (fallback). Showing ${shownFiles} of ${totalFiles} files.`);
			}

			async function pickFolder() {
				try {
					rootHandle = await window.showDirectoryPicker({ mode: 'read' });
					fallbackFiles = null;
					refreshBtn.disabled = false;
					await renderFromHandle(rootHandle);
				} catch (e) {
					// User cancelled or unsupported.
					if (e && e.name === 'AbortError') return;
					setStatus('Folder picker not available; use the fallback button.');
				}
			}

			function pickFolderFallback() {
				fallbackPicker.click();
			}

			// Wire up UI
			pickFolderBtn.addEventListener('click', pickFolder);
			refreshBtn.addEventListener('click', async () => {
				if (rootHandle) {
					await renderFromHandle(rootHandle);
					return;
				}
				if (fallbackFiles) {
					const index = buildFallbackIndex(fallbackFiles);
					renderFallbackTree(index);
				}
			});
			onlyC.addEventListener('change', async () => {
				if (rootHandle) {
					await renderFromHandle(rootHandle);
					return;
				}
				if (fallbackFiles) {
					const index = buildFallbackIndex(fallbackFiles);
					renderFallbackTree(index);
				}
			});
			fallbackBtn.addEventListener('click', pickFolderFallback);
			fallbackPicker.addEventListener('change', () => {
				fallbackFiles = fallbackPicker.files;
				rootHandle = null;
				refreshBtn.disabled = false;
				const index = buildFallbackIndex(fallbackFiles);
				renderFallbackTree(index);
			});

			// Show fallback picker button if needed
			const supportsDirectoryPicker = typeof window.showDirectoryPicker === 'function';
			if (!supportsDirectoryPicker) {
				fallbackBtn.hidden = false;
				pickFolderBtn.disabled = true;
				setStatus('Your browser does not support folder picker. Use fallback button.');
			} else {
				// Still offer fallback in case permissions are blocked.
				fallbackBtn.hidden = false;
			}
		</script>
	</body>
</html>
